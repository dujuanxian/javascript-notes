# 作用域

## 编译原理
将JavaScript 归类为__“动态”__或__“解释执行”__语言，但事实上它是一门__编译语言__。与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系
统中进行移植。

在传统编译语言的流程中，源代码在执行之前会经历三个步骤，统称为“编译”: 
1. 分词/词法分析（Tokenizing/Lexing）
    
    将字符串分解成词法单元（token）
2. 解析/语法分析（Parsing）
    
    将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为**“抽象语法树”（Abstract Syntax Tree，AST）**
3. 代码生成  
    
    将AST转换为可执行代码的过程

Javascript引擎编译过程：
在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。编译发生在代码执行前的几微秒（甚至更短！）的时间内，
JavaScript引擎会用各种办法（比如JIT）来优化性能。

## 理解作用域
`var a = 2;`变量的赋值操作会执行两个操作：
- 编译器会在当前作用域中声明一个变量（如果之前没有声明过）
- __在运行时__引擎会__在作用域中__查找该变量，如果能够找到就会对它赋值

### LHS查询 & RHS查询
LHS: 试图找到变量的容器本身，从而可以对其赋值
RHS：取到它的源值

```javascript
function foo(a) {
  console.log( a ); // 2
}
foo( 2 );
```
- foo(..) 函数的调用需要对foo 进行RHS 引用 
    
    _误区_：将函数声明`function foo(a) {...` 概念化为普通的变量声明和赋值，比如`var foo`、`foo ＝ function(a){...`。
    然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。
- 给参数a（隐式地）分配值，需要进行一次LHS 查询
- console 进行RHS 引用，
- 这里还有对a 进行的RHS 引用， 并且将得到的值传给了console.log(..)

_为什么区分LHS 和RHS 是一件重要的事情？_

- RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常
- RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，那么引擎会抛出另外一种类型的异常，叫作TypeError。
- 在非“严格模式”下，LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎
- ES5中引入了“严格模式”。严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查询失败时，引擎会抛出同RHS查询失败时类似的ReferenceError异常。

ReferenceError 同作用域判别失败相关，而TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。